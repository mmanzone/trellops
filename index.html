<!DOCTYPE html>
<html>
<head>
    <title>Trello Stats Dashboard</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <style>
        /* ------------------------------------------------ */
        /* --- DIGITAL-7 FONT LOAD (FIXED MONO FONT) --- */
        /* ------------------------------------------------ */
        @import url('https://fonts.cdnfonts.com/css/digital-7-mono');

        /* ------------------------------------------------ */
        /* --- Modern & Minimalist Theme --- */
        /* ------------------------------------------------ */
        :root {
            --bg-primary: #f7f8fa;
            --bg-secondary: #ffffff;
            --text-color: #222222;
            --text-secondary: #555555;
            --border-color: #e0e0e0;
            --primary-color: #ced7de;
            --primary-hover-color: #b0b9c0;
            --danger-color: #dc3545;
            --danger-hover-color: #c82333;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --label-border-color: #555555;
        }

        [data-theme="dark"] {
            --bg-primary: #1c1c1e;
            --bg-secondary: #2c2c2e;
            --text-color: #e0e0e0;
            --text-secondary: #aaaaaa;
            --border-color: #444;
            --primary-color: #9aa8b3;
            --primary-hover-color: #82919c;
            --danger-color: #dc3545;
            --danger-hover-color: #e06c75;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --label-border-color: #ffffff;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0 0 80px 0;
            background-color: var(--bg-primary);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            padding: 40px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* --- Typography --- */
        h1, h2, h3, h4 {
            font-weight: 600;
            color: var(--text-color);
            margin-top: 0;
        }

        /* --- Buttons --- */
        button, .settings-button, .logout-button, .save-layout-button, .refresh-button, label.settings-button {
            background-color: var(--primary-color);
            color: #222;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            height: 34px; /* Consistent height */
            box-sizing: border-box;
        }

        button:hover, .settings-button:hover, .logout-button:hover, .save-layout-button:hover, .refresh-button:hover, label.settings-button:hover {
            background-color: var(--primary-hover-color);
            transform: translateY(-1px);
        }

        button:disabled, .settings-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }

        .button-danger {
            background-color: var(--danger-color);
            color: white;
        }
        .button-danger:hover {
            background-color: var(--danger-hover-color);
        }
        
        .button-secondary {
            background-color: var(--bg-secondary);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        .button-secondary:hover {
            background-color: var(--bg-primary);
        }

        /* --- Header/Navigation --- */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }
        .header-title-area {
            display: flex;
            align-items: center;
            flex-grow: 1;
            max-width: 70%; 
        }
        .header h1 {
            margin: 0;
            font-size: 2em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .large-clock {
            font-family: 'Digital-7 Mono', monospace;
            font-size: 2.5em;
            font-weight: 900; 
            color: var(--text-color);
            letter-spacing: 2px;
            margin-right: 20px;
            flex-shrink: 0;
            min-width: 155px; 
            text-align: right;
        }
        .header-actions {
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }
        .countdown {
            margin-right: 15px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        
        /* NEW: Time Filter & Theme Toggle */
        .time-filter-select, .theme-toggle-button {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-secondary);
            color: var(--text-color);
            font-size: 0.9em;
            margin-left: 10px;
        }
        .theme-toggle-button {
            cursor: pointer;
        }

        /* NEW: Fixed Footer Action Bar */
        .footer-action-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 15px 40px;
            background-color: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            box-shadow: 0 -2px 10px var(--shadow-color);
            z-index: 9000;
        }
        .footer-action-bar .version {
            margin-right: auto; 
            font-size: 0.8em;
            color: var(--text-secondary);
        }
        .footer-action-bar > * {
            margin-left: 10px;
        }

        /* --- Dashboard Grid Layout --- */
        .dashboard-section {
            padding: 20px;
            background-color: transparent;
        }
        .section-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .section-header {
            font-size: 1.8em;
            font-weight: 700;
        }
        .collapse-toggle {
            cursor: pointer;
            font-size: 1.5em;
            color: var(--text-secondary);
            padding: 5px;
            background: none;
            border: none;
            transition: color 0.2s;
        }
        .collapse-toggle:hover {
            color: var(--primary-color);
        }
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        /* --- Tile Styles --- */
        .dashboard-tile {
            min-height: 160px;
            border-radius: 12px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 15px var(--shadow-color);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            border: none;
            color: white;
        }
        .dashboard-tile:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
            transform: translateY(-5px);
        }
        .card-count {
            font-size: 5em;
            font-weight: 700;
            line-height: 1;
        }
        .list-name {
            font-size: 1.2em;
            font-weight: 500;
            margin-top: 10px;
        }
        .card-description {
            font-size: 0.9em;
            font-weight: 400;
            opacity: 0.9;
            max-width: 90%;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            margin-top: 5px;
        }

        /* --- Forms & Settings --- */
        .form-card {
            background-color: var(--bg-secondary);
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
            max-width: 95%;
            margin: 20px auto;
            position: relative;
        }
        .form-card label {
            margin-bottom: 10px;
            font-weight: 500;
            display: block;
            color: var(--text-secondary);
        }
        .form-card input[type="text"],
        .form-card input[type="number"],
        .form-card select {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1em;
            box-sizing: border-box;
            background-color: var(--bg-primary);
            color: var(--text-color);
        }
        .list-config-item {
            display: flex;
            align-items: center;
            margin-top: 10px;
            padding: 12px;
            background: var(--bg-primary); 
            border: 1px solid var(--border-color);
            border-radius: 8px;
            justify-content: space-between; 
        }
        
        .list-config-item > span:first-child {
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            width: 50%;
            padding-right: 10px;
        }
        .list-config-item > div:last-child {
             display: flex;
             align-items: center;
        }
        
        .order-buttons button, .section-order-buttons button {
            background: var(--bg-secondary);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            width: 30px;
            height: 30px;
            padding: 0;
            margin: 0 2px;
        }
        .order-buttons button:hover, .section-order-buttons button:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* --- Layout Configuration --- */
        .layout-config-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .layout-section-box {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        .layout-list-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 8px;
        }
        
        /* --- Modal Display --- */
        .modal-overlay {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        .modal-content {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh; 
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        .modal-content h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            font-size: 1.5em;
        }
        .card-label {
            font-size: 0.75em;
            font-weight: 500;
            padding: 3px 6px;
            border-radius: 4px;
            margin-right: 5px;
            border: 1px solid var(--label-border-color);
        }
        .card-list-item {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .card-list-item a {
            color: var(--text-color);
            text-decoration: none;
            flex-grow: 1; 
        }

        .admin-section {
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            background-color: var(--bg-secondary);
        }

        .admin-section h3 {
            margin-top: 0;
        }

        .actions-container {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .section-options {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .section-options label {
            font-weight: normal;
            font-size: 0.9em;
            margin: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
        }

        .sub-option {
            margin-left: 0;
        }

        .modal-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .modal-actions button, .modal-actions label {
            width: 100%;
        }
        .modal-actions label.settings-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .settings-row label {
            margin-bottom: 0;
            flex-shrink: 0;
        }
        .settings-row select, .settings-row input {
            margin-top: 0;
            width: auto;
            flex-grow: 1;
        }
        .options-row > div {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* --- Landing Page Styles --- */
        .landing-page {
            background-color: #121212;
            color: #e0e0e0;
            padding: 0;
            margin: 0;
            width: 100%;
            overflow-x: hidden;
        }

        .landing-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 60px 20px;
            text-align: center;
        }

        .hero-section {
            padding: 80px 0;
        }

        .hero-section .logo {
            width: 120px;
            height: 120px;
            margin: 0 auto 20px;
        }

        .hero-section h1 {
            font-size: 4em;
            font-weight: 700;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .hero-section p {
            font-size: 1.5em;
            color: #aaaaaa;
            margin-bottom: 30px;
        }

        .hero-section .cta-button {
            background-color: #00c6ff;
            color: #121212;
            font-size: 1.2em;
            padding: 15px 30px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            transition: background-color 0.3s, transform 0.2s;
        }

        .hero-section .cta-button:hover {
            background-color: #2a8dff;
            transform: translateY(-2px);
        }

        .hero-section .tagline {
            margin-top: 30px;
            font-size: 1.1em;
            color: #999;
        }

        .value-prop-section {
            background-color: #1e1e1e;
            padding: 80px 0;
        }

        .value-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 40px;
            margin-top: 40px;
        }

        .value-item {
            padding: 20px;
        }

        .value-item .icon {
            font-size: 3em;
            margin-bottom: 20px;
        }

        .value-item h3 {
            font-size: 1.5em;
            color: #ffffff;
            margin-bottom: 10px;
        }

        .value-item p {
            color: #aaaaaa;
        }

        .features-section {
            padding: 80px 0;
        }

        .features-section h2 {
            font-size: 2.5em;
            margin-bottom: 50px;
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 40px;
            text-align: left;
        }

        .feature-item {
            background-color: #1e1e1e;
            padding: 30px;
            border-radius: 12px;
        }

        .feature-item h4 {
            font-size: 1.3em;
            color: #ffffff;
            margin-bottom: 10px;
        }

        .feature-item p {
            color: #aaaaaa;
        }

        .final-cta-section {
            background-color: #007aff;
            color: white;
            padding: 60px 20px;
        }

        .final-cta-section p {
            font-size: 1.5em;
            font-weight: 500;
            margin-bottom: 30px;
        }

        .final-cta-section .cta-button {
            background-color: #ffffff;
            color: #007aff;
            font-size: 1.2em;
            padding: 15px 30px;
        }

        @media (max-width: 768px) {
            .hero-section h1 {
                font-size: 3em;
            }

            .value-grid {
                grid-template-columns: 1fr;
            }

            .features-grid {
                grid-template-columns: 1fr;
            }
        }

    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef, useContext, createContext } = React;
        const ReactDOM = window.ReactDOM;

        // IMPORTANT: Replace with your Trello API Key
        const TRELLO_API_KEY = "44382b25e75ceb100edaa4d308acf019"; 

        // --- Trello OAuth Integration ---
        const trelloAuth = {
            login: () => {
                const appName = "Trello Stats Dashboard";
                const returnUrl = window.location.href.split('#')[0]; // Remove any existing hash
                const authUrl = `https://trello.com/1/authorize?expiration=never&name=${encodeURIComponent(appName)}&scope=read&response_type=token&key=${TRELLO_API_KEY}&return_url=${encodeURIComponent(returnUrl)}`;
                window.location.href = authUrl;
            },
            getTokenFromUrl: () => {
                const hash = window.location.hash.substring(1);
                if (hash.startsWith('token=')) {
                    const token = hash.substring(6);
                    // Clean the URL
                    history.pushState("", document.title, window.location.pathname + window.location.search);
                    return token;
                }
                return null;
            },
            logout: (setCurrentUser) => {
                // For OAuth, logout is primarily a client-side action
                setCurrentUser(null); 
                // No specific token to clear globally, it's per user
            }
        };


        const TRELLO_API_BASE = "https://api.trello.com/1";
        const REFRESH_INTERVAL_SECONDS = 30;

        // --- Public Sound Files (REMOVED) ---
        const NOTIFICATION_SOUNDS = {
            'none': { label: 'None', url: '' }
        };


        // --- Local Storage Keys ---
        const STORAGE_KEYS = {
            CURRENT_USER: 'trelloCurrentUser',
            USER_DATA: 'trelloUserData',
            THEME: 'dashboardTheme',
            CLOCK_SETTING: 'dashboardClockSetting_',
            REFRESH_INTERVAL: 'dashboardRefreshInterval_',
            RANDOM_COLORS_CACHE: 'dashboardRandomColors'
        };
        
        // --- User-Specific Storage Helpers ---
        const getCurrentUser = () => {
            return localStorage.getItem(STORAGE_KEYS.CURRENT_USER);
        };

        const setCurrentUser = (userId) => {
            if (userId) {
                localStorage.setItem(STORAGE_KEYS.CURRENT_USER, userId);
            } else {
                localStorage.removeItem(STORAGE_KEYS.CURRENT_USER);
            }
        };

        const getUserData = (userId, key) => {
            if (!userId) return null;
            const allUserData = JSON.parse(localStorage.getItem(STORAGE_KEYS.USER_DATA)) || {};
            const userData = allUserData[userId] || {};
            return userData[key];
        };

        const setUserData = (userId, key, value) => {
            if (!userId) return;
            const allUserData = JSON.parse(localStorage.getItem(STORAGE_KEYS.USER_DATA)) || {};
            if (!allUserData[userId]) {
                allUserData[userId] = {};
            }
            allUserData[userId][key] = value;
            localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(allUserData));
        };
        
        // --- Filter Options Mapping ---
        const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        const now = new Date();
        
        const calcCalendarFilter = (key) => {
            let start, end;
            if (key === 'last_month') {
                start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                end = new Date(now.getFullYear(), now.getMonth(), 0);
                const monthName = MONTH_NAMES[start.getMonth()];
                return { start, end, label: `Last month (${monthName} ${start.getFullYear()})`, titleSuffix: `${monthName} ${start.getFullYear()}` };
            } else if (key === 'this_month') {
                start = new Date(now.getFullYear(), now.getMonth(), 1);
                end = now;
                const monthName = MONTH_NAMES[now.getMonth()];
                return { start, end, label: `This month (${monthName} ${now.getFullYear()})`, titleSuffix: `${monthName} ${now.getFullYear()}` };
            } else if (key === 'this_week') {
                const dayOfWeek = now.getDay(); 
                const daysToSubtract = (dayOfWeek === 0 ? 6 : dayOfWeek - 1);
                
                start = new Date(now);
                start.setDate(now.getDate() - daysToSubtract);
                start.setHours(0, 0, 0, 0); 
                
                end = now; 
                return { start, end, label: `This week (Mon-Sun)`, titleSuffix: `This Week` };
            } else if (key === 'last_week') {
                const dayOfWeek = now.getDay();
                const daysToSubtract = (dayOfWeek === 0 ? 6 : dayOfWeek - 1) + 7;
                
                start = new Date(now);
                start.setDate(now.getDate() - daysToSubtract);
                start.setHours(0, 0, 0, 0); 
                
                end = new Date(start);
                end.setDate(start.getDate() + 6);
                end.setHours(23, 59, 59, 999);
                return { start, end, label: `Last week (Mon-Sun)`, titleSuffix: `Last Week` };
            }
        };

        const TIME_FILTERS = {
            'all': { label: 'All Time', minutes: 0, titleSuffix: 'All Time', type: 'absolute' },
            '24h': { label: 'Last 24h', minutes: 60 * 24, titleSuffix: 'Last 24h', type: 'relative' },
            '48h': { label: 'Last 48h', minutes: 60 * 48, titleSuffix: 'Last 48h', type: 'relative' },
            '72h': { label: 'Last 72h', minutes: 60 * 72, titleSuffix: 'Last 72h', type: 'relative' },
            '7d': { label: 'Last 7 days', minutes: 60 * 24 * 7, titleSuffix: 'Last 7 Days', type: 'relative' },
            
            'this_week': { ...calcCalendarFilter('this_week'), type: 'calendar' },
            'last_week': { ...calcCalendarFilter('last_week'), type: 'calendar' },
            
            'last_30d': { label: 'Last 30 days', minutes: 60 * 24 * 30, titleSuffix: 'Last 30 Days', type: 'relative' },
            'this_month': { ...calcCalendarFilter('this_month'), type: 'calendar' },
            'last_month': { ...calcCalendarFilter('last_month'), type: 'calendar' },
        };

        // --- Dark Mode Context ---
        const DarkModeContext = createContext();

        const useDarkMode = () => {
            const [theme, setTheme] = useState(() => localStorage.getItem(STORAGE_KEYS.THEME) || 'system');

            useEffect(() => {
                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                
                const applyTheme = (currentTheme) => {
                    const resolvedTheme = 
                        currentTheme === 'system' 
                            ? (mediaQuery.matches ? 'dark' : 'light')
                            : currentTheme;
                    document.documentElement.setAttribute('data-theme', resolvedTheme);
                };
                
                applyTheme(theme);
                
                const handleChange = () => applyTheme(theme);
                mediaQuery.addEventListener('change', handleChange);
                
                return () => mediaQuery.removeEventListener('change', handleChange);
            }, [theme]);
            
            const toggleTheme = (newTheme) => {
                const resolvedTheme = newTheme || (theme === 'light' ? 'dark' : 'light');
                setTheme(resolvedTheme);
                localStorage.setItem(STORAGE_KEYS.THEME, resolvedTheme);
            };

            return { theme, toggleTheme };
        };

        const DarkModeProvider = ({ children }) => {
            const darkMode = useDarkMode();
            return (
                <DarkModeContext.Provider value={darkMode}>
                    {children}
                </DarkModeContext.Provider>
            );
        };
        // ------------------------------------------------


        // --- Utility Functions (continued) ---
        
        // FIX: Hoisted to global scope to resolve ReferenceError
        const calculateDateFilter = (filterKey) => {
            const filter = TIME_FILTERS[filterKey];
            let params = '';

            if (filter.type === 'relative' && filterKey !== 'all') {
                const now = new Date();
                now.setMinutes(now.getMinutes() - filter.minutes);
                params = `&since=${now.toISOString()}`;
            } else if (filter.type === 'calendar') {
                const { start, end } = filter;
                
                if (start) {
                    params += `&since=${start.toISOString()}`;
                }
                if (end && filterKey !== 'this_month' && filterKey !== 'this_week') {
                    params += `&before=${end.toISOString()}`;
                }
            }

            return params;
        };
        
        // Helper to convert units to seconds for validation
        const convertIntervalToSeconds = (value, unit) => {
            const numValue = parseInt(value) || 0;
            if (unit === 'seconds') return numValue;
            if (unit === 'minutes') return numValue * 60;
            if (unit === 'hours') return numValue * 3600;
            return 30; // Default if invalid
        };
        
        // Helper to convert units to milliseconds for setInterval
        const convertIntervalToMilliseconds = (value, unit) => {
            return convertIntervalToSeconds(value, unit) * 1000;
        };
        // ------------------------------------------------


        const getOrGenerateRandomColor = (listId, existingColors) => {
            let cache = JSON.parse(localStorage.getItem(STORAGE_KEYS.RANDOM_COLORS_CACHE)) || {};
            let color = cache[listId];
            
            const DEFAULT_FALLBACK_COLOR = '#dcdcdc'; 

            if (!color) {
                let r, g, b;
                do {
                    r = Math.floor(Math.random() * 101);
                    g = Math.floor(Math.random() * 101);
                    b = Math.floor(Math.random() * 101);
                    color = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
                } while (existingColors.has(color)); 
                
                cache[listId] = color;
                localStorage.setItem(STORAGE_KEYS.RANDOM_COLORS_CACHE, JSON.stringify(cache));
            }
            return color || DEFAULT_FALLBACK_COLOR; 
        };
        
        const trelloFetch = async (path, token) => {
            if (!token) {
                throw new Error("Trello authentication token not provided.");
            }
            const url = `${TRELLO_API_BASE}${path}${path.includes('?') ? '&' : '?'}key=${TRELLO_API_KEY}&token=${token}`;
            const response = await fetch(url);
            if (!response.ok) {
                const errorText = await response.text();
                let errorMessage = errorText;
                try {
                    const errorJson = JSON.parse(errorText);
                    if (errorJson && errorJson.message) {
                        errorMessage = errorJson.message;
                    }
                } catch (e) {
                    // Not a JSON response, just use the raw text.
                }

                // Check specifically for Rate Limit error (429)
                if (response.status === 429) {
                     throw new Error(`Rate limit exceeded (429): Trello API requests too fast/frequent.`);
                }
                // Handle invalid token error (401)
                if (response.status === 401) {
                    throw new Error(`Invalid or expired token. Please log in again. (Details: ${errorMessage})`);
                }
                throw new Error(errorMessage || `Trello API error: ${response.status}`);
            }
            return response.json();
        };

        // --- Persistent Storage Management ---
        const getPersistentColors = (userId) => {
            try {
                return getUserData(userId, 'listColors') || {};
            } catch (e) { return {}; }
        };
        const setPersistentColor = (userId, boardId, listId, color) => {
            const colors = getPersistentColors(userId);
            if (!colors[boardId]) { colors[boardId] = {}; }
            colors[boardId][listId] = color;
            setUserData(userId, 'listColors', colors);
        };
        
        // Alert Persistence (REMOVED)
        const getPersistentSelections = (userId, boardId) => {
            try {
                const allSelections = getUserData(userId, 'listSelections') || {};
                return new Set(allSelections[boardId] || []);
            } catch (e) { return new Set(); }
        };
        const setPersistentSelections = (userId, boardId, listIds) => {
            try {
                const allSelections = getUserData(userId, 'listSelections') || {};
                allSelections[boardId] = Array.from(listIds);
                setUserData(userId, 'listSelections', allSelections);
            } catch (e) { console.error("Error saving list selections to cache:", e); }
        };

        // Dashboard Layout Management
        const DEFAULT_LAYOUT = [{ id: 'all', name: 'All', listIds: [], ignoreFirstCard: false, displayFirstCardDescription: true, isCollapsed: false }];

        const getPersistentLayout = (userId, boardId) => {
            try {
                const layout = getUserData(userId, 'dashboardLayout') || {};
                const savedLayout = layout[boardId] || DEFAULT_LAYOUT;
                return savedLayout.map(s => ({
                    ...s,
                    isCollapsed: s.isCollapsed || false,
                    ignoreFirstCard: s.ignoreFirstCard || false,
                    displayFirstCardDescription: s.displayFirstCardDescription !== false // Default to true
                }));
            } catch (e) {
                console.error("Error parsing dashboard layout:", e);
                return DEFAULT_LAYOUT;
            }
        };

        const setPersistentLayout = (userId, boardId, layout) => {
            try {
                const allLayouts = getUserData(userId, 'dashboardLayout') || {};
                allLayouts[boardId] = layout;
                setUserData(userId, 'dashboardLayout', allLayouts);
            } catch (e) {
                console.error("Error saving dashboard layout:", e);
            }
        };
        // ------------------------------------------------

        // --- Component: Clock ---
        const DigitalClock = ({ boardId }) => {
            const [time, setTime] = useState('');
            const [showClock, setShowClock] = useState(() => localStorage.getItem(STORAGE_KEYS.CLOCK_SETTING + boardId) !== 'false');

            useEffect(() => {
                const timer = setInterval(() => {
                    const now = new Date();
                    setTime(now.toLocaleTimeString(undefined, { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' }));
                }, 1000);
                return () => clearInterval(timer);
            }, []);
            
            useEffect(() => {
                const savedSetting = localStorage.getItem(STORAGE_KEYS.CLOCK_SETTING + boardId);
                if (savedSetting === null) {
                    localStorage.setItem(STORAGE_KEYS.CLOCK_SETTING + boardId, 'true');
                }
                setShowClock(savedSetting !== 'false');
            }, [boardId]);

            if (!showClock) return null;

            return (
                <div className="large-clock">
                    {time || '--:--:--'}
                </div>
            );
        };

        // --- Component: Card Details Modal ---
        const CardDetailsModal = ({ listId, listName, color, token, onClose, sectionsLayout }) => {
            const [cards, setCards] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState('');
            const { theme } = useContext(DarkModeContext);
            
            // Determine if the first card should be ignored based on section settings
            const section = sectionsLayout.find(s => s.listIds.includes(listId));
            const shouldIgnoreFirst = section?.ignoreFirstCard || false;


            useEffect(() => {
                setLoading(true);
                setError('');
                trelloFetch(`/lists/${listId}/cards?fields=id,name,shortUrl,labels`, token) 
                    .then(data => {
                        // Conditionally filter the first card based on setting
                        const filteredCards = shouldIgnoreFirst ? data.slice(1) : data;
                        setCards(filteredCards);
                    })
                    .catch(e => {
                        console.error("Card fetch error:", e);
                        setError(`Failed to load cards for this list: ${e.message}`);
                    })
                    .finally(() => setLoading(false));
            }, [listId, token, shouldIgnoreFirst]);

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <span className="modal-close" onClick={onClose}>&times;</span>
                        <h3 style={{color: color, borderColor: color}}>Cards in: {listName} ({cards.length})</h3>

                        {loading && <p>Loading cards...</p>}
                        {error && <p className="error">{error}</p>}

                        {!loading && cards.length === 0 && <p>No cards found in this list.</p>}

                        {!loading && cards.length > 0 && (
                            <div>
                                {cards.map(card => (
                                    <div key={card.id} className="card-list-item">
                                        {/* Display Trello Labels */}
                                        {/* FIX: Use optional chaining to prevent crash if labels is null/undefined */}
                                        {card.labels?.map(label => (
                                            <span 
                                                key={label.id} 
                                                className="card-label"
                                                style={{
                                                    backgroundColor: label.color || '#999',
                                                    color: getLabelTextColor(theme)
                                                }}
                                            >
                                                {label.name || label.color}
                                            </span>
                                        ))}

                                        <a href={card.shortUrl} target="_blank" rel="noopener noreferrer" title={card.name}>
                                            {card.name}
                                        </a>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };
        
        const getLabelTextColor = (theme) => {
            const resolvedTheme = 
                theme === 'system' 
                    ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
                    : theme;
            return resolvedTheme === 'dark' ? '#ffffff' : '#222222';
        };

        const LandingPage = ({ onLogin }) => {
            return (
                <div className="landing-page">
                    <div className="hero-section">
                        <div className="landing-container">
                            <img src="powerupicon2.png" alt="Trellops Logo" className="logo" />
                            <h1>Trellops</h1>
                            <p>Transform Your Trello Boards into Real-Time Operational Dashboards.</p>
                            <a href="#" className="cta-button" onClick={onLogin}>Try Trellops Now!</a>
                            <p className="tagline">Simple. Powerful. Visible.</p>
                        </div>
                    </div>

                    <div className="value-prop-section">
                        <div className="landing-container">
                            <div className="value-grid">
                                <div className="value-item">
                                    <div className="icon">ðŸ“Š</div>
                                    <h3>Real-Time Wallboard</h3>
                                    <p>See instant, close-to-realtime workload metrics for any Trello list. Perfect for wall screens and command centers.</p>
                                </div>
                                <div className="value-item">
                                    <div className="icon">âœ¨</div>
                                    <h3>Uncluttered Simplicity</h3>
                                    <p>Go beyond cluttered lists. Display only essential card counts in a clean, customizable tile-based interface.</p>
                                </div>
                                <div className="value-item">
                                    <div className="icon">ðŸ”’</div>
                                    <h3>Secure & Private</h3>
                                    <p>We only require READ access to your Trello boards. All your layout settings are stored locally on your computer.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="features-section">
                        <div className="landing-container">
                            <h2 style={{ color: '#ffffff' }}>Your Trello Data, Your Rules</h2>
                            <div className="features-grid">
                                <div className="feature-item">
                                    <h4>Custom Tile Sections</h4>
                                    <p>Group lists into collapsible Sections to organize your dashboard and focus on what matters most.</p>
                                </div>
                                <div className="feature-item">
                                    <h4>Time Filtered Counts</h4>
                                    <p>Filter card totals based on creation date to see trends and monitor recent activity.</p>
                                </div>
                                <div className="feature-item">
                                    <h4>Skip Description Cards</h4>
                                    <p>Automatically exclude the first card in a list from the total, so you can use it for instructions without skewing your metrics.</p>
                                </div>
                                <div className="feature-item">
                                    <h4>Effortless Sharing</h4>
                                    <p>Easily export and import dashboard layouts to share your setup with your team or across different computers.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="final-cta-section">
                        <div className="landing-container">
                            <p>Ready to level up your operational visibility? Trellops is the dedicated Trello dashboard you've been waiting for.</p>
                            <a href="#" className="cta-button" onClick={onLogin}>Login with Trello</a>
                        </div>
                    </div>
                </div>
            );
        };

        // 1. Authentication Screen
        const LoginPage = ({ onLoginSuccess }) => {
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);

            const handleLoginClick = () => {
                setLoading(true);
                trelloAuth.login();
            };
            
            return (
                <div className="landing-page" style={{ minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                    <div style={{ background: '#1e1e1e', padding: '40px', borderRadius: '12px', textAlign: 'center', maxWidth: '500px', width: '90%' }}>
                        <img src="powerupicon2.png" alt="Trellops Logo" style={{ width: '80px', height: '80px', margin: '0 auto 20px' }} />
                        <h2 style={{ color: '#ffffff' }}>Get started with Trellops</h2>
                        <p style={{fontSize: '1em', lineHeight: '1.6', marginBottom: '30px', color: '#aaaaaa'}}>
                            To access your Trello dashboard, please log in using your Atlassian Trello account. Trellops will request read-only access to your boards and lists. Your credentials are not stored on our server, and none of your information is shared with the develpoper. Everything is private, secure and remains on your computer only.
                        </p>
                        {error && <div className="error" style={{ color: '#dc3545', marginBottom: '15px' }}>{error}</div>}
                        
                        <a href="#" className="cta-button" onClick={handleLoginClick} disabled={loading} style={{width: '100%', backgroundColor: '#007aff', color: 'white', fontSize: '1.1em', padding: '12px 24px', textDecoration: 'none', display: 'block'}}>
                            {loading ? 'Redirecting...' : 'Log In with Trello'}
                        </a>
                    </div>
                </div>
            );
        };

        // 2. Settings Screen
        const SettingsScreen = ({ user, onSave, onBack, onLogout }) => {
            const initialSettings = getUserData(user.id, 'settings') || {};
            const [boards, setBoards] = useState([]);
            const [selectedBoardId, setSelectedBoardId] = useState(initialSettings.boardId || '');
            const [allBoardLists, setAllBoardLists] = useState([]);
            
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);

            // --- Section Management State ---
            const [sections, setSections] = useState(() => getPersistentLayout(user.id, initialSettings.boardId));
            const [listColors, setListColors] = useState(() => (getPersistentColors(user.id)[initialSettings.boardId] || {}));
            const [newSectionName, setNewSectionName] = useState('');
            const [showMoreOptions, setShowMoreOptions] = useState(false);
            
            // Clock setting state for settings screen
            const [showClockSetting, setShowClockSetting] = useState(() => localStorage.getItem(STORAGE_KEYS.CLOCK_SETTING + initialSettings.boardId) !== 'false');
            
            // Theme setting from Context
            const { theme, toggleTheme } = useContext(DarkModeContext);

            // NEW: Refresh Interval State
            const defaultRefreshSetting = { value: 1, unit: 'minutes' };
            const savedRefresh = localStorage.getItem(STORAGE_KEYS.REFRESH_INTERVAL + initialSettings.boardId);
            const [refreshValue, setRefreshValue] = useState(savedRefresh ? JSON.parse(savedRefresh).value : 1);
            const [refreshUnit, setRefreshUnit] = useState(savedRefresh ? JSON.parse(savedRefresh).unit : 'minutes');


            // --- Export/Import Handlers ---
            const handleExportConfig = () => {
                if (!selectedBoardId) {
                    setError("Please select a board before exporting.");
                    return;
                }

                const configData = {
                    theme: localStorage.getItem(STORAGE_KEYS.THEME),
                    clockSetting: localStorage.getItem(STORAGE_KEYS.CLOCK_SETTING + selectedBoardId),
                    refreshInterval: localStorage.getItem(STORAGE_KEYS.REFRESH_INTERVAL + selectedBoardId),
                    layout: getPersistentLayout(user.id, selectedBoardId),
                    colors: getPersistentColors(user.id)[selectedBoardId],
                    // NOTE: API Key and Token are EXCLUDED for security
                    boardName: allBoardLists.find(b => b.id === selectedBoardId)?.name || 'UnknownBoard'
                };

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(configData, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", `trello_dashboard_config_${configData.boardName.replace(/\s/g, '_')}.json`);
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            };

            const handleImportConfig = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedConfig = JSON.parse(e.target.result);
                        if (!selectedBoardId) {
                            setError("Please select the target Trello board first.");
                            return;
                        }
                        
                        // 1. Update Theme
                        if (importedConfig.theme) {
                            toggleTheme(importedConfig.theme);
                        }
                        // 2. Update Refresh Rate
                        if (importedConfig.refreshInterval) {
                            localStorage.setItem(STORAGE_KEYS.REFRESH_INTERVAL + selectedBoardId, importedConfig.refreshInterval);
                            const { value: rValue, unit: rUnit } = JSON.parse(importedConfig.refreshInterval);
                            setRefreshValue(rValue);
                            setRefreshUnit(rUnit);
                        }
                        // 3. Update Clock Setting
                        if (importedConfig.clockSetting !== undefined) {
                            localStorage.setItem(STORAGE_KEYS.CLOCK_SETTING + selectedBoardId, importedConfig.clockSetting);
                            setShowClockSetting(importedConfig.clockSetting !== 'false');
                        }
                        // 4. Update Layout (Sections)
                        if (importedConfig.layout) {
                            setPersistentLayout(user.id, selectedBoardId, importedConfig.layout);
                            setSections(getPersistentLayout(user.id, selectedBoardId));
                        }
                        // 5. Update Colors
                        if (importedConfig.colors) {
                            const allColors = getPersistentColors(user.id);
                            allColors[selectedBoardId] = importedConfig.colors;
                            setUserData(user.id, 'listColors', allColors);
                            setListColors(importedConfig.colors);
                        }

                        alert(`Configuration successfully imported for board ${selectedBoardId}.`);
                        // Force full settings refresh to apply changes
                        onSave({ boardId: selectedBoardId, boardName: importedConfig.boardName || 'Imported Board', selectedLists: [] });

                    } catch (err) {
                        setError("Invalid configuration file format.");
                        console.error("Import error:", err);
                    }
                };
                reader.readAsText(file);
            };

            // NEW: Handle Clearing Board Configuration
            const handleClearBoardConfig = () => {
                if (!selectedBoardId) {
                    setError("Please select a board to clear configuration.");
                    return;
                }
                
                const boardName = boards.find(b => b.id === selectedBoardId)?.name || 'this board';

                if (window.confirm(`Are you sure you want to reset the layout for the board: "${boardName}"? This cannot be undone.`)) {
                    // 1. Clear Layout
                    const allLayouts = getUserData(user.id, 'dashboardLayout') || {};
                    delete allLayouts[selectedBoardId];
                    setUserData(user.id, 'dashboardLayout', allLayouts);

                    // 2. Reset component state to default values
                    setSections(DEFAULT_LAYOUT);
                    
                    alert(`Layout cleared for "${boardName}". The dashboard will now reset.`);
                    
                    // Force a re-save and switch to dashboard (which will prompt re-setup)
                    onSave({ boardId: selectedBoardId, boardName: boardName, selectedLists: [] });
                }
            };


            // Fetch Boards on load
            useEffect(() => {
                setLoading(true);
                trelloFetch('/members/me/boards', user.token)
                    .then(data => {
                        setBoards(data);
                        if (data.length > 0 && !selectedBoardId) {
                            setSelectedBoardId(data[0].id);
                        }
                    })
                    .catch(e => setError(e.message))
                    .finally(() => setLoading(false));
            }, [user.token]);

            // Fetch Lists and initialize states when selectedBoardId changes
            useEffect(() => {
                if (!selectedBoardId) return;
                setLoading(true);
                setError('');

                const boardPersistentColors = getPersistentColors(user.id)[selectedBoardId] || {};
                const boardLayout = getPersistentLayout(user.id, selectedBoardId);
                const clockSetting = localStorage.getItem(STORAGE_KEYS.CLOCK_SETTING + selectedBoardId) !== 'false';
                
                // Read refresh setting
                const savedRefresh = localStorage.getItem(STORAGE_KEYS.REFRESH_INTERVAL + selectedBoardId);
                const { value: rValue, unit: rUnit } = savedRefresh ? JSON.parse(savedRefresh) : defaultRefreshSetting;


                trelloFetch(`/boards/${selectedBoardId}/lists?cards=none&fields=id,name`, user.token)
                    .then(data => {
                        setAllBoardLists(data);
                        setListColors(boardPersistentColors);
                        setSections(boardLayout);
                        setShowClockSetting(clockSetting);
                        setRefreshValue(rValue);
                        setRefreshUnit(rUnit);
                    })
                    .catch(e => setError(e.message))
                    .finally(() => setLoading(false));
            }, [selectedBoardId, user.token]);

            // --- HANDLERS ---

            const handleBoardChange = (e) => {
                const newId = e.target.value;
                setSelectedBoardId(newId);
                // Reset sections/colors/clock, will be reloaded by useEffect
                setSections(getPersistentLayout(user.id, newId));
                setListColors(getPersistentColors(user.id)[newId] || {});
                setAllBoardLists([]);
                setShowClockSetting(localStorage.getItem(STORAGE_KEYS.CLOCK_SETTING + newId) !== 'false');

                const savedRefresh = localStorage.getItem(STORAGE_KEYS.REFRESH_INTERVAL + newId);
                const { value: rValue, unit: rUnit } = savedRefresh ? JSON.parse(savedRefresh) : defaultRefreshSetting;
                setRefreshValue(rValue);
                setRefreshUnit(rUnit);
            };

            const handleAddSection = () => {
                if (!newSectionName.trim()) return;
                const newSection = {
                    id: Date.now().toString(),
                    name: newSectionName.trim(),
                    listIds: [],
                    ignoreFirstCard: false,
                    displayFirstCardDescription: true,
                    isCollapsed: false
                };
                const newLayout = [...sections, newSection];
                setSections(newLayout);
                setNewSectionName('');
                setPersistentLayout(user.id, selectedBoardId, newLayout);
            };

            const handleRemoveSection = (sectionId) => {
                const sectionToRemove = sections.find(s => s.id === sectionId);
                if (!sectionToRemove) return;

                const listIdsToMoveBack = sectionToRemove.listIds;

                // Add lists from the removed section back to the 'All' section
                const newSections = sections
                    .filter(s => s.id !== sectionId)
                    .map(s => {
                        if (s.id === 'all') {
                             return { ...s, listIds: [...s.listIds, ...listIdsToMoveBack] };
                        }
                        return s;
                    });

                // Ensure 'All' section exists if it was somehow deleted
                if (!newSections.some(s => s.id === 'all')) {
                    newSections.unshift({ id: 'all', name: 'All', listIds: listIdsToMoveBack, ignoreFirstCard: false, isCollapsed: false });
                }

                setSections(newSections);
                setPersistentLayout(user.id, selectedBoardId, newSections);
            };
            
            // Handler for re-ordering sections
            const handleReorderSection = (sectionId, direction) => {
                const currentSections = [...sections];
                const index = currentSections.findIndex(s => s.id === sectionId);
                if (index === -1) return;

                const newIndex = direction === 'up' ? index - 1 : index + 1;
                
                // Only allow swap if the new index is valid and not swapping 'all' (index 0) with any other element
                if (newIndex > 0 && newIndex < currentSections.length && currentSections[newIndex].id !== 'all') 
                {
                    [currentSections[index], currentSections[newIndex]] = [currentSections[newIndex], currentSections[index]];

                    setSections(currentSections);
                    setPersistentLayout(user.id, selectedBoardId, currentSections);
                }
            };


            // Allows renaming of all sections, including 'all'
            const handleRenameSection = (sectionId, newName) => {
                if (!newName.trim()) return;
                const newSections = sections.map(s => s.id === sectionId ? { ...s, name: newName } : s);
                setSections(newSections);
                setPersistentLayout(user.id, selectedBoardId, newSections);
            };

            // Handler for the 'Use first card as description' checkbox
            const handleToggleIgnoreCard = (sectionId, isChecked) => {
                const newSections = sections.map(s => 
                    s.id === sectionId ? { ...s, ignoreFirstCard: isChecked } : s
                );
                setSections(newSections);
                setPersistentLayout(user.id, selectedBoardId, newSections);
            };

            // Handler for the 'Display first card as description' checkbox
            const handleToggleDisplayDescription = (sectionId, isChecked) => {
                const newSections = sections.map(s => 
                    s.id === sectionId ? { ...s, displayFirstCardDescription: isChecked } : s
                );
                setSections(newSections);
                setPersistentLayout(user.id, selectedBoardId, newSections);
            };
            
            // Handler for the Clock checkbox
            const handleToggleClock = (isChecked) => {
                setShowClockSetting(isChecked);
                localStorage.setItem(STORAGE_KEYS.CLOCK_SETTING + selectedBoardId, isChecked ? 'true' : 'false');
            };
            
            // Alert Handler (REMOVED)
            const handleToggleAlert = (listId) => { /* No Op */ };
            const handleSoundChange = (e) => { /* No Op */ };
            const testSound = () => { /* No Op */ };


            // Handler for re-ordering tiles
            const handleReorderList = (sectionId, listId, direction) => {
                const newSections = sections.map(section => {
                    if (section.id !== sectionId) return section;

                    const listIds = [...section.listIds];
                    const index = listIds.indexOf(listId);

                    if (index === -1) return section;

                    const newIndex = direction === 'up' ? index - 1 : index + 1;

                    if (newIndex >= 0 && newIndex < listIds.length) {
                        // Swap elements
                        [listIds[index], listIds[newIndex]] = [listIds[newIndex], listIds[index]];
                        return { ...section, listIds };
                    }
                    return section;
                });

                setSections(newSections);
                setPersistentLayout(user.id, selectedBoardId, newSections);
            };


            const handleMoveList = (listId, fromSectionId, toSectionId) => {
                const newSections = sections.map(section => {
                    if (section.id === fromSectionId) {
                        return { ...section, listIds: section.listIds.filter(id => id !== listId) };
                    }
                    if (section.id === toSectionId) {
                        return { ...section, listIds: [...section.listIds, listId] };
                    }
                    return section;
                });
                
                // Handle move to pool ("Unassigned Lists")
                if (toSectionId === 'pool') {
                    const updatedSections = newSections.map(s => 
                       ({ ...s, listIds: s.listIds.filter(id => id !== listId) })
                    );
                    
                    const allSelectedIds = updatedSections.flatMap(s => s.listIds);
                    setPersistentSelections(user.id, selectedBoardId, allSelectedIds);
                    setSections(updatedSections);
                    setPersistentLayout(user.id, selectedBoardId, updatedSections);
                    return;
                }
                
                setSections(newSections);
                setPersistentLayout(user.id, selectedBoardId, newSections);

                // Update persistent selections cache (add listId)
                const allSelectedIds = newSections.flatMap(s => s.listIds);
                setPersistentSelections(user.id, selectedBoardId, allSelectedIds);
            };

            const handleColorChange = (listId, color) => {
                const newColors = { ...listColors, [listId]: color };
                setListColors(newColors);
                setPersistentColor(user.id, selectedBoardId, listId, color);
            };
            
            // Handle Refresh Rate Change
            const handleRefreshChange = (value, unit) => {
                const newValue = parseInt(value) || 0;
                setRefreshValue(newValue);
                if (unit) setRefreshUnit(unit);
                
                // Save immediately
                localStorage.setItem(STORAGE_KEYS.REFRESH_INTERVAL + selectedBoardId, JSON.stringify({
                    value: newValue,
                    unit: unit || refreshUnit
                }));
            };


            const handleSave = () => {
                const selectedBoard = boards.find(b => b.id === selectedBoardId);
                if (!selectedBoard) {
                    setError('Please select a board.');
                    return;
                }
                
                // Final validation before saving settings/returning
                const intervalInSeconds = convertIntervalToSeconds(refreshValue, refreshUnit);
                if (intervalInSeconds < 10) {
                    setError('Minimum refresh rate is 10 seconds.');
                    return;
                }
                if (intervalInSeconds > 7200) { // 2 hours = 7200 seconds
                    setError('Maximum refresh rate is 2 hours.');
                    return;
                }
                // Save final refresh setting
                localStorage.setItem(STORAGE_KEYS.REFRESH_INTERVAL + selectedBoardId, JSON.stringify({
                    value: refreshValue,
                    unit: refreshUnit
                }));


                // Gather all lists that are currently assigned to ANY section
                const selectedListsMap = new Map();
                sections.flatMap(s => s.listIds).forEach(listId => {
                    const listData = allBoardLists.find(l => l.id === listId);
                    if (listData) {
                        selectedListsMap.set(listId, {
                            id: listId,
                            name: listData.name,
                            color: listColors[listId] || ''
                        });
                    }
                });

                // Update the main SETTINGS cache for dashboard initialization
                const finalSettings = {
                    boardId: selectedBoardId,
                    boardName: selectedBoard.name,
                    selectedLists: Array.from(selectedListsMap.values())
                };

                setUserData(user.id, 'settings', finalSettings);
                onSave(finalSettings);
            };

            // Derive list pool: Trello lists not currently assigned to any section
            const assignedListIds = new Set(sections.flatMap(s => s.listIds));
            const listPool = allBoardLists
                .filter(list => !assignedListIds.has(list.id))
                .map(list => ({ id: list.id, name: list.name }));
            
            // Get the ID of the first section for the default move action
            const firstSectionId = sections[0].id;

            if (loading) return <div className="form-card settings">Loading Boards...</div>;

            return (
                <div className="form-card settings">
                     <div style={{position: 'absolute', top: '10px', right: '10px'}}>
                        <button className="logout-button" onClick={onLogout} style={{margin: 0}}>Log Out</button>
                    </div>
                    <h2>Dashboard Setup</h2>
                    {error && <div className="error">{error}</div>}

                    <div className="admin-section">
                        <h3>General Settings</h3>
                        <div className="settings-row">
                            <label htmlFor="board-select">Trello board:</label>
                            <select id="board-select" value={selectedBoardId} onChange={handleBoardChange}>
                                <option value="">-- Select a Board --</option>
                                {boards.map(board => (
                                    <option key={board.id} value={board.id}>{board.name}</option>
                                ))}
                            </select>
                        </div>

                        {selectedBoardId && (
                            <div className="settings-row options-row">
                                <div>
                                    <label>Auto-Refresh:</label>
                                    <input
                                        type="number"
                                        min="1"
                                        value={refreshValue}
                                        onChange={e => handleRefreshChange(e.target.value)}
                                        style={{width: '60px'}}
                                    />
                                    <select 
                                        value={refreshUnit} 
                                        onChange={e => handleRefreshChange(refreshValue, e.target.value)}
                                    >
                                        <option value="seconds">Seconds</option>
                                        <option value="minutes">Minutes</option>
                                        <option value="hours">Hours</option>
                                    </select>
                                </div>
                                
                                <div>
                                    <input 
                                        type="checkbox" 
                                        id="show-clock-check"
                                        checked={showClockSetting}
                                        onChange={e => handleToggleClock(e.target.checked)}
                                    />
                                    <label htmlFor="show-clock-check">Show Clock</label>
                                </div>
                                
                                <div>
                                    <label htmlFor="theme-select">Theme:</label>
                                    <select 
                                        id="theme-select"
                                        value={theme} 
                                        onChange={(e) => toggleTheme(e.target.value)} 
                                    >
                                        <option value="system">System</option>
                                        <option value="light">Light</option>
                                        <option value="dark">Dark</option>
                                    </select>
                                </div>
                            </div>
                        )}
                    </div>


                    {selectedBoardId && (
                        <div className="admin-section">
                            <h3>Manage sections and tiles</h3>

                            <div className="section-management">
                                <h4 style={{marginTop: 0}}>Manage Sections</h4>
                                <input
                                    type="text"
                                    placeholder="New Section Name"
                                    value={newSectionName}
                                    onChange={e => setNewSectionName(e.target.value)}
                                    className="section-title-input"
                                    style={{width: '200px', marginRight: '10px'}}
                                />
                                <button className="settings-button" onClick={handleAddSection} disabled={!newSectionName.trim()}>
                                    Add Section
                                </button>
                            </div>

                            <div className="layout-config-container">
                                {/* LIST POOL (Unassigned Lists) - Fixed at top, full width */}
                                <div className="layout-section-box" style={{flexBasis: '100%', maxWidth: '100%', flexShrink: 0}}>
                                    <h4 style={{marginBottom: '10px', color: '#6b778c'}}>Unassigned Lists ({listPool.length})</h4>
                                    <div className="list-pool" style={{minHeight: '100px', display: 'flex', flexWrap: 'wrap', gap: '10px'}}>
                                        {listPool.map(list => (
                                            <div key={list.id} className="layout-list-item" style={{justifyContent: 'flex-start', flexWrap: 'wrap', gap: '10px', flexBasis: 'auto', flexGrow: 0}}>
                                                <span style={{flexGrow: 1}}>{list.name}</span>
                                                {/* Render move button for ALL sections */}
                                                {sections.map(section => (
                                                    <button 
                                                        key={section.id}
                                                        className="move-button-pool" 
                                                        onClick={() => handleMoveList(list.id, 'pool', section.id)}
                                                        title={`Move to ${section.name}`}
                                                    >
                                                        {section.name.substring(0, 5)} &raquo;
                                                    </button>
                                                ))}
                                            </div>
                                        ))}
                                        {listPool.length === 0 && <p style={{fontSize: '0.9em', color: '#6b778c'}}>All lists assigned.</p>}
                                    </div>
                                </div>

                                {/* CONFIGURED SECTIONS (Stacked Vertically) */}
                                {sections.map((section, sectionIndex) => (
                                    <div key={section.id} className="layout-section-box" style={{flexGrow: 1, maxWidth: '100%'}}>
                                        
                                        <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px'}}>
                                            <div style={{display: 'flex', alignItems: 'center', flexGrow: 1}}>
                                                {/* Section Reorder Buttons */}
                                                <div className="section-order-buttons" style={{marginRight: '15px'}}>
                                                    <button 
                                                        onClick={() => handleReorderSection(section.id, 'up')}
                                                        disabled={sectionIndex === 0} 
                                                        title="Move Section Up"
                                                    >
                                                        â–²
                                                    </button>
                                                    <button 
                                                        onClick={() => handleReorderSection(section.id, 'down')}
                                                        disabled={sectionIndex === sections.length - 1}
                                                        title="Move Section Down"
                                                    >
                                                        â–¼
                                                    </button>
                                                </div>
                                                
                                                {/* Allows renaming of all sections (including "All") */}
                                                <input
                                                    type="text"
                                                    value={section.name}
                                                    onChange={e => handleRenameSection(section.id, e.target.value)}
                                                    className="section-title-input"
                                                    style={{width: 'calc(100% - 15px)'}}
                                                />
                                            </div>

                                            {section.id !== 'all' && (
                                                <button
                                                    className="remove-section-button"
                                                    onClick={() => handleRemoveSection(section.id)}
                                                    title="Delete section and move lists to 'All'"
                                                >
                                                    &times;
                                                </button>
                                            )}
                                        </div>

                                        {section.listIds.length > 0 ? (
                                            section.listIds.map((listId, index) => {
                                                const listData = allBoardLists.find(l => l.id === listId);
                                                if (!listData) return null;

                                                const isAlertEnabled = false; // Alert removed

                                                return (
                                                    <div key={listId} className="list-config-item">
                                                        
                                                        {/* List Name - FIXED WIDTH/TRUNCATION */}
                                                        <span style={{
                                                            overflow: 'hidden',
                                                           
                                                            textOverflow: 'ellipsis', 
                                                            width: '50%' 
                                                        }}>
                                                            {listData.name}
                                                        </span>

                                                        {/* Color Picker, Tile Order, Move Dropdown Group */}
                                                        <div style={{display: 'flex', alignItems: 'center'}}>
                                                            
                                                            {/* Color Picker */}
                                                            <input
                                                                type="color"
                                                                value={listColors[listId] || '#cccccc'}
                                                                onChange={e => handleColorChange(listId, e.target.value)}
                                                                title="Choose Tile Color"
                                                                style={{marginLeft: '10px'}}
                                                            />

                                                            {/* Tile Order Buttons */}
                                                            <div className="order-buttons">
                                                                <button 
                                                                    onClick={() => handleReorderList(section.id, listId, 'up')}
                                                                    disabled={index === 0}
                                                                    title="Move Up"
                                                                >
                                                                    â–²
                                                                </button>
                                                                <button 
                                                                    onClick={() => handleReorderList(section.id, listId, 'down')}
                                                                    disabled={index === section.listIds.length - 1}
                                                                    title="Move Down"
                                                                >
                                                                    â–¼
                                                                </button>
                                                            </div>

                                                            {/* Move/Remove Dropdown */}
                                                            <select
                                                                onChange={e => handleMoveList(listId, section.id, e.target.value)}
                                                                style={{marginLeft: '10px', padding: '5px', fontSize: '0.8em', width: '85px'}}
                                                                value={section.id}
                                                            >
                                                                <option value={section.id}>Move...</option>
                                                                <optgroup label="Sections">
                                                                    {sections.map(s => (
                                                                        s.id !== section.id && <option key={s.id} value={s.id}>{s.name}</option>
                                                                ))}
                                                            </optgroup>
                                                            <optgroup label="Unassigned">
                                                                <option value="pool">Move to Pool</option>
                                                            </optgroup>
                                                        </select>
                                                            </div>
                                                    </div>
                                                );
                                            })
                                        ) : (
                                            <p style={{fontSize: '0.9em', color: '#6b778c'}}>Move lists here.</p>
                                        )}
                                        
                                        {/* Section Options (Use first card as description) */}
                                        <div className="section-options">
                                            <label>
                                                <input 
                                                    type="checkbox" 
                                                    checked={section.ignoreFirstCard}
                                                    onChange={e => handleToggleIgnoreCard(section.id, e.target.checked)}
                                                />
                                                Do not include the first card in the total
                                            </label>
                                            {section.ignoreFirstCard && (
                                                <label className="sub-option">
                                                    <input 
                                                        type="checkbox" 
                                                        checked={section.displayFirstCardDescription}
                                                        onChange={e => handleToggleDisplayDescription(section.id, e.target.checked)}
                                                    />
                                                    Display the first card as a description
                                                </label>
                                            )}
                                        </div>

                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    
                    {/* Global Notification Settings (REMOVED) */}

                    <div className="actions-container">
                        <button className="save-layout-button" onClick={handleSave}> 
                            Save Layout & View Dashboard
                        </button>
                        <button className="button-secondary" onClick={onBack}>
                            Cancel changes
                        </button>
                        <button className="button-secondary" onClick={() => setShowMoreOptions(true)}>
                            More options...
                        </button>
                    </div>

                    {showMoreOptions && (
                        <MoreOptionsModal
                            onClose={() => setShowMoreOptions(false)}
                            onExport={handleExportConfig}
                            onImport={handleImportConfig}
                            onReset={handleClearBoardConfig}
                            boardName={boards.find(b => b.id === selectedBoardId)?.name || ''}
                            selectedBoardId={selectedBoardId}
                        />
                    )}
                </div>
            );
        };

        const MoreOptionsModal = ({ onClose, onExport, onImport, onReset, boardName, selectedBoardId }) => {
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <span className="modal-close" onClick={onClose}>&times;</span>
                        <h3>More Options</h3>
                        <div className="modal-actions">
                            <button 
                                className="settings-button" 
                                onClick={onExport}
                                disabled={!selectedBoardId}
                            >
                                Export configuration for {boardName}
                            </button>

                            <label htmlFor="import-file-input" className="settings-button">
                                Import a configuration file for {boardName}
                                <input 
                                    type="file" 
                                    id="import-file-input" 
                                    accept=".json" 
                                    onChange={onImport} 
                                    style={{display: 'none'}}
                                />
                            </label>
                            <button 
                                className="button-danger" 
                                onClick={onReset}
                                disabled={!selectedBoardId}
                            >
                                Reset the layout for the {boardName}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // 3. Dashboard View
        const Dashboard = ({ user, settings, onShowSettings, onLogout }) => {
            const [counts, setCounts] = useState(new Map());
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState('');
            const [countdown, setCountdown] = useState(30);
            const [timeFilter, setTimeFilter] = useState('all'); 
            const timerRef = useRef(null);

            const buildNumber = (() => {
                const now = new Date();
                const year = now.getFullYear().toString().slice(-2);
                const month = (now.getMonth() + 1).toString().padStart(2, '0');
                const day = now.getDate().toString().padStart(2, '0');
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                return `3.${year}${month}${day}${hours}${minutes}`;
            })();

            const [modalList, setModalList] = useState(null);

            const boardId = settings?.boardId;
            const boardName = settings?.boardName;
            const listsFromSettings = settings?.selectedLists || [];

            const sectionsLayout = boardId ? getPersistentLayout(user.id, boardId) : DEFAULT_LAYOUT;
            
            const allListsMap = new Map(listsFromSettings.map(list => [list.id, list]));
            const persistentColors = getPersistentColors(user.id);
            // Removed listAlerts reading

            // Removed alertSoundKey/Url

            // Removed usePrevious hook

            // Define sectionsMap for rendering/lookup
            const sectionsMap = new Map(sectionsLayout.map(s => [s.id, s]));

            // Toggle section collapse state
            const handleToggleCollapse = (sectionId) => {
                const newLayout = sectionsLayout.map(s => 
                    s.id === sectionId ? { ...s, isCollapsed: !s.isCollapsed } : s
                );
                setPersistentLayout(user.id, boardId, newLayout);
                fetchListCounts(true);
            };
            
            // Get theme context for toggle button
            const { theme, toggleTheme } = useContext(DarkModeContext);
            
            // NEW: Get refresh interval setting
            const defaultRefreshSetting = { value: 1, unit: 'minutes' };
            const savedRefresh = localStorage.getItem(STORAGE_KEYS.REFRESH_INTERVAL + boardId);
            const refreshSetting = savedRefresh ? JSON.parse(savedRefresh) : defaultRefreshSetting;
            const refreshIntervalMs = convertIntervalToMilliseconds(refreshSetting.value, refreshSetting.unit);


            const fetchListCounts = useCallback(async (manual = false) => {
                if (manual || loading) {
                    setLoading(true);
                }
                setError('');

                const persistentColorsCopy = getPersistentColors(user.id); 
                const currentLayout = getPersistentLayout(user.id, boardId);
                const currentSectionsMap = new Map(currentLayout.map(s => [s.id, s]));
                const usedColors = new Set(Object.values(persistentColorsCopy).flatMap(b => Object.values(b)));

                const dateFilterParam = calculateDateFilter(timeFilter);
                
                const uniqueListIds = new Set(currentLayout.flatMap(s => s.listIds));

                if (uniqueListIds.size === 0) {
                    setCounts(new Map());
                    setLoading(false);
                    return;
                }
                
                try {
                    // --- API OPTIMIZATION: Single Call for Board Data ---
                    // Fetch all cards from the board with necessary fields
                    const allCards = await trelloFetch(
                        `/boards/${boardId}/cards?fields=id,idList,name${dateFilterParam}`, 
                        user.token
                    );

                    const listResults = {};
                    
                    // 2. Process results
                    allCards.forEach(card => {
                        // Ignore cards not in a selected list
                        if (!uniqueListIds.has(card.idList)) return;
                        
                        if (!listResults[card.idList]) {
                            listResults[card.idList] = {
                                count: 0,
                                firstCardName: ''
                            };
                        }
                        
                        // Count total cards
                        listResults[card.idList].count++;

                        // Capture the name of the first card we encounter in the single batch fetch.
                        if (listResults[card.idList].firstCardName === '') {
                            listResults[card.idList].firstCardName = card.name;
                        }
                    });

                    // 3. Final calculation and mapping
                    const countsMap = new Map();
                    
                    Array.from(uniqueListIds).forEach(listId => {
                        const listData = allListsMap.get(listId);
                        const section = currentLayout.find(s => s.listIds.includes(listId));
                        
                        const isIgnored = section?.ignoreFirstCard;
                        const displayDescription = section?.displayFirstCardDescription;
                        const result = listResults[listId] || { count: 0, firstCardName: '' };
                        
                        let finalCount = result.count;
                        if (isIgnored && finalCount > 0) {
                            finalCount -= 1;
                        }

                        let color = persistentColors[boardId]?.[listId] || listData?.color;
                        if (!color || color === '#cccccc') {
                            color = getOrGenerateRandomColor(listId, usedColors);
                        }

                        countsMap.set(listId, {
                            listId: listId,
                            count: finalCount,
                            name: listData?.name,
                            displayColor: color,
                            firstCardName: isIgnored && displayDescription ? result.firstCardName : '' 
                        });
                    });
                    
                    setCounts(countsMap);

                } catch (e) {
                    console.error("Dashboard fetch error:", e);
                    setError(e.message);
                } finally {
                    setLoading(false);
                }
            }, [user.token, listsFromSettings.length, boardId, sectionsLayout.length, timeFilter]);

            // Interval setup
            useEffect(() => {
                               if (timerRef.current) {
                    clearInterval(timerRef.current);
                }

                const interval = setInterval(() => {
                    setCountdown(prev => {
                        if (prev <= 1) {
                            fetchListCounts();
                            return convertIntervalToSeconds(refreshSetting.value, refreshSetting.unit);
                        }
                        return prev - 1;
                    });
                }, 1000);

                timerRef.current = interval;
                
                // Set initial countdown value and fetch
                setCountdown(convertIntervalToSeconds(refreshSetting.value, refreshSetting.unit));
                fetchListCounts();

                return () => clearInterval(interval);
            }, [fetchListCounts, refreshIntervalMs]);


            const handleTileClick = (listId, listName, color) => {
                setModalList({ listId, listName, color, sectionsLayout }); // Pass layout to modal
            };

            const handleCloseModal = () => {
                setModalList(null);
            };
            
            const filterLabel = TIME_FILTERS[timeFilter].titleSuffix;
            const clockSetting = localStorage.getItem(STORAGE_KEYS.CLOCK_SETTING + boardId);
            const showClock = clockSetting !== 'false';


            if (loading && listsFromSettings.length === 0) return <div className="container" style={{textAlign: 'center', marginTop: '50px'}}>Loading dashboard data...</div>;

            if (error) return <div className="container"><div className="error">{error}</div></div>;

            if (!boardName || listsFromSettings.length === 0) {
                 return (
                    <div className="container">
                        <div className="header">
                            <h1>ðŸ“Š Trello Dashboard</h1>
                            <button className="logout-button" onClick={onLogout}>Log Out</button>
                        </div>
                        <p style={{textAlign: 'center', marginTop: '50px'}}>
                            No board or lists configured. Please go to settings to set up your dashboard.
                        </p>
                        <div style={{textAlign: 'center', marginTop: '20px'}}>
                            <button className="settings-button" onClick={onShowSettings}>Go to Settings</button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="container">
                    <div className="header">
                        <div className="header-title-area">
                            {/* Large Clock */}
                            {showClock && <DigitalClock boardId={boardId} />}
                            {/* Title with time filter */}
                            <h1>{boardName} dashboard - {filterLabel}</h1>
                        </div>
                        
                        <div className="header-actions-top">
                            {/* Time Filter Dropdown */}
                            <select className="time-filter-select" value={timeFilter} onChange={e => setTimeFilter(e.target.value)}>
                                {Object.keys(TIME_FILTERS).map(key => (
                                    <option key={key} value={key}>{TIME_FILTERS[key].label}</option>
                                ))}
                            </select>
                            
                            
                            {/* Theme Toggle Button */}
                            <button className="theme-toggle-button" onClick={() => toggleTheme()}>
                                {theme === 'dark' ? 'â˜€ï¸ Light' : 'ðŸŒ™ Dark'}
                            </button>
                        </div>
                    </div>

                    {/* RENDER SECTIONS */}
                    {sectionsLayout.map(section => {
                        const sectionTiles = section.listIds
                            .map(listId => {
                                const tileData = counts.get(listId);
                                
                                // Placeholder Logic
                                if (!tileData) {
                                    const list = allListsMap.get(listId);
                                    if (list) {
                                        const color = list.color || getOrGenerateRandomColor(list.id, new Set());
                                        
                                        return { listId: list.id, name: list.name, count: '...', displayColor: color, firstCardName: '' };
                                    }
                                    return undefined;
                                }
                                return tileData;
                            })
                            .filter(item => item !== undefined);

                        // Determine collapse state
                        const isCollapsed = sectionsMap.get(section.id)?.isCollapsed || false;

                        if (sectionTiles.length === 0 && !isCollapsed) return null;

                        return (
                            <div key={section.id} className="dashboard-section">
                                <div className="section-header-row">
                                    <div className="section-header">{section.name}</div>
                                    <button 
                                        className="collapse-toggle" 
                                        onClick={() => handleToggleCollapse(section.id)}
                                        title={isCollapsed ? 'Show Tiles' : 'Hide Tiles'}
                                    >
                                        {isCollapsed ? (
                                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true" focusable="false">
                                                <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.02 18.02 0 0 1 5.06-5.06"></path>
                                                <path d="M4.22 4.22L12 12m5.07-5.07A10.07 10.07 0 0 1 23 12s-4 8-11 8c-1.85 0-3.61-.5-5.17-1.42"></path>
                                                <line x1="1" y1="1" x2="23" y2="23"></line>
                                            </svg>
                                        ) : (
                                            <svg className="icon-eye" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                                <circle cx="12" cy="12" r="3"></circle>
                                            </svg>
                                        )}
                                    </button>
                                </div>
                                
                                {/* Conditionally render the grid */}
                                {!isCollapsed && (
                                    <div className="dashboard-grid">
                                        {sectionTiles.map((item) => (
                                            <div
                                                key={item.listId}
                                                className="dashboard-tile"
                                                style={{
                                                    backgroundColor: item.displayColor,
                                                    color: 'white'
                                                }}
                                                onClick={() => handleTileClick(item.listId, item.name, item.displayColor)}
                                            >
                                                <div className="card-count">{item.count}</div>
                                                <div className="list-name">{item.name}</div>
                                                {/* Display first card name if available */}
                                                {item.firstCardName && (
                                                    <div className="card-description" title={item.firstCardName}>
                                                        {item.firstCardName}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        );
                    })}


                    {modalList && (
                        <CardDetailsModal
                            listId={modalList.listId}
                            listName={modalList.listName}
                            color={modalList.color}
                            token={user.token}
                            onClose={handleCloseModal}
                            sectionsLayout={sectionsLayout} 
                        />
                    )}

                    {/* NEW: Fixed Footer Action Bar */}
                    <div className="footer-action-bar">
                        <span className="version">v.3</span>
                        <span className="countdown">Next refresh in {countdown}s</span>
                        <button className="refresh-button" onClick={() => fetchListCounts(true)}>Refresh Data</button>
                        <button className="settings-button" onClick={onShowSettings}>Settings</button>
                        <button className="logout-button" onClick={onLogout}>Log Out</button>
                    </div>
                </div>
            );
        };

        // 4. Main Application Component
        const App = () => {
            const [user, setUser] = useState(null);
            const [settings, setSettings] = useState(null);
            const [view, setView] = useState('auth'); // 'auth', 'settings', 'dashboard'
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState('');

           

            // Check for token in URL on initial load
            useEffect(() => {
                const tokenFromUrl = trelloAuth.getTokenFromUrl();
                if (tokenFromUrl) {
                    handleLoginSuccess(tokenFromUrl);
                } else {
                    // If no token in URL, check if a user is already logged in
                    const loggedInUserId = getCurrentUser();
                    if (loggedInUserId) {
                        // This is a simplified example. In a real app, you'd re-validate the token.
                        // For this version, we assume the token is still valid.
                        const userData = JSON.parse(localStorage.getItem(STORAGE_KEYS.USER_DATA)) || {};
                        const userSession = userData[loggedInUserId];
                        if (userSession && userSession.token) {
                             handleLoginSuccess(userSession.token);
                        } else {
                            setView('landing');
                            setLoading(false); // No valid session found
                        }
                    } else {
                        setView('landing');
                        setLoading(false);
                    }
                }
            }, []);

            const handleLoginSuccess = async (token) => {
                setLoading(true);
                setError('');
                try {
                    const member = await trelloFetch('/members/me', token);
                    const userData = { id: member.id, username: member.username, token: token };
                    
                    // Store user session data
                    setUserData(member.id, 'token', token);
                    setUserData(member.id, 'username', member.username);
                    setCurrentUser(member.id);

                    setUser(userData);
                    
                    const savedSettings = getUserData(member.id, 'settings');
                    if (savedSettings && savedSettings.boardId) {
                        setSettings(savedSettings);
                        setView('dashboard');
                    } else {
                        setView('settings');
                    }
                } catch (e) {
                    console.error("Login validation failed:", e);
                    setError("Failed to validate Trello session. Please log in again.");
                    setCurrentUser(null); // Clear invalid user session
                    setView('auth');
                } finally {
                    setLoading(false);
                }
            };

            const handleLogout = () => {
                if (user) {
                    // In a real app, you might want to revoke the token via Trello's API
                    // trelloFetch(`/tokens/${user.token}`, 'DELETE');
                    setUserData(user.id, 'token', null); // Invalidate the stored token
                }
                setCurrentUser(null);
                setUser(null);
                setSettings(null);
                setView('landing');
            };

            const handleSaveSettings = (newSettings) => {
                setSettings(newSettings);
                setView('dashboard');
            };

            if (loading) {
                return <div className="container" style={{textAlign: 'center', marginTop: '50px'}}>Initializing...</div>;
            }
            
            if (error) {
                 return (
                    <div className="container">
                        <div className="error" style={{textAlign: 'center', marginTop: '50px'}}>{error}</div>
                        <div style={{textAlign: 'center', marginTop: '20px'}}>
                            <button className="settings-button" onClick={() => { setError(''); setView('auth'); }}>Go to Login</button>
                        </div>
                    </div>
                );
            }

            if (view === 'login') {
                return <LoginPage onLoginSuccess={handleLoginSuccess} />;
            }

            if (view === 'dashboard') {
                return <Dashboard user={user} settings={settings} onShowSettings={() => setView('settings')} onLogout={handleLogout} />;
            }

            if (view === 'settings') {
                return <SettingsScreen user={user} onSave={handleSaveSettings} onBack={() => setView('dashboard')} onLogout={handleLogout} />;
            }

            return <LandingPage onLogin={() => setView('login')} />;
        };

        ReactDOM.render(
            <DarkModeProvider>
                <App />
            </DarkModeProvider>,
            document.getElementById('root')
        );
    </script>
</body>
</html>
